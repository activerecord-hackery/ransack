"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[591],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return m}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=a.createContext({}),c=function(e){var n=a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=c(e.components);return a.createElement(i.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,i=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=c(t),m=r,k=u["".concat(i,".").concat(m)]||u[m]||p[m]||l;return t?a.createElement(k,s(s({ref:n},d),{},{components:t})):a.createElement(k,s({ref:n},d))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,s=new Array(l);s[0]=u;var o={};for(var i in n)hasOwnProperty.call(n,i)&&(o[i]=n[i]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var c=2;c<l;c++)s[c]=t[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},3128:function(e,n,t){t.r(n),t.d(n,{assets:function(){return d},contentTitle:function(){return i},default:function(){return m},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return p}});var a=t(7462),r=t(3366),l=(t(7294),t(3905)),s=["components"],o={sidebar_position:6,title:"Ransackers"},i=void 0,c={unversionedId:"going-further/ransackers",id:"going-further/ransackers",title:"Ransackers",description:"Add custom search functions",source:"@site/docs/going-further/ransackers.md",sourceDirName:"going-further",slug:"/going-further/ransackers",permalink:"/ransack/going-further/ransackers",editUrl:"https://github.com/activerecord-hackery/ransack/edit/main/docs/docs/going-further/ransackers.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,title:"Ransackers"},sidebar:"tutorialSidebar",previous:{title:"Merging searches",permalink:"/ransack/going-further/merging-searches"},next:{title:"Saving queries",permalink:"/ransack/going-further/saving-queries"}},d={},p=[{value:"Add custom search functions",id:"add-custom-search-functions",level:2},{value:"Arel",id:"arel",level:2},{value:"Example Ransackers",id:"example-ransackers",level:2},{value:"Search on field",id:"search-on-field",level:3},{value:"Search using Datetime",id:"search-using-datetime",level:3},{value:"2.1",id:"21",level:4},{value:"2.2. Postgresql with time zones",id:"22-postgresql-with-time-zones",level:4},{value:"Postgres columns",id:"postgres-columns",level:3},{value:"Type conversions",id:"type-conversions",level:3},{value:"Concatenated fields",id:"concatenated-fields",level:3},{value:"Passing arguments",id:"passing-arguments",level:3},{value:"Dropdowns",id:"dropdowns",level:3},{value:"Testing for existence",id:"testing-for-existence",level:3},{value:"Associations",id:"associations",level:3},{value:"Search on translations",id:"search-on-translations",level:3}],u={toc:p};function m(e){var n=e.components,t=(0,r.Z)(e,s);return(0,l.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"add-custom-search-functions"},"Add custom search functions"),(0,l.kt)("p",null,"The main premise behind Ransack is to provide access to ",(0,l.kt)("strong",{parentName:"p"},"Arel predicate methods"),". Ransack provides special methods, called ",(0,l.kt)("em",{parentName:"p"},"ransackers"),", for creating additional search functions via Arel."),(0,l.kt)("p",null,"A ",(0,l.kt)("inlineCode",{parentName:"p"},"ransacker")," method can ",(0,l.kt)("strong",{parentName:"p"},"return any Arel node that allows the usual predicate methods"),". Custom ",(0,l.kt)("inlineCode",{parentName:"p"},"ransacker"),"s are an expert feature, and require a thorough understanding of Arel."),(0,l.kt)("h2",{id:"arel"},"Arel"),(0,l.kt)("p",null,"Here are some resources for more information about Arel:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://robots.thoughtbot.com/using-arel-to-compose-sql-queries"},"Using Arel to Compose SQL Queries")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"http://jpospisil.com/2014/06/16/the-definitive-guide-to-arel-the-sql-manager-for-ruby.html"},"The definitive guide to Arel, the SQL manager for Ruby")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://www.cloudbees.com/blog/creating-advanced-active-record-db-queries-arel"},"Creating Advanced Active Record DB Queries with Arel"))),(0,l.kt)("p",null,"Ransacker methods enable search customization and are placed in the model. Arguments may be passed to a ransacker method via ",(0,l.kt)("inlineCode",{parentName:"p"},"ransacker_args")," (see Example #6 below)."),(0,l.kt)("p",null,"Ransackers, like scopes, are not a cure-all. Many use cases can be better solved with a standard Ransack search on a dedicated database search field, which is faster, index-able, and scales better than converting/ransacking data on the fly."),(0,l.kt)("h2",{id:"example-ransackers"},"Example Ransackers"),(0,l.kt)("h3",{id:"search-on-field"},"Search on field"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Search on the ",(0,l.kt)("inlineCode",{parentName:"em"},"name")," field reversed:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},"# in the model:\nransacker :reversed_name, formatter: proc { |v| v.reverse } do |parent|\n  parent.table[:name]\nend\n")),(0,l.kt)("h3",{id:"search-using-datetime"},"Search using Datetime"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Convert a user ",(0,l.kt)("inlineCode",{parentName:"em"},"string")," input and a database ",(0,l.kt)("inlineCode",{parentName:"em"},"datetime")," field to the same ",(0,l.kt)("inlineCode",{parentName:"em"},"date")," format to find all records with a ",(0,l.kt)("inlineCode",{parentName:"em"},"datetime")," field (",(0,l.kt)("inlineCode",{parentName:"em"},"created_at")," in this example) equal to that date :")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},"# in the model:\nransacker :created_at do\n  Arel.sql('date(created_at)')\nend\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erb"},"in the view:\n<%= f.search_field(\n  :created_at_date_equals, placeholder: t(:date_format)\n  ) %>\n...\n<%= sort_link(@search, :created_at, default_order: :desc) %>\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},"# config/initializers/ransack.rb\nRansack.configure do |config|\n  config.add_predicate 'date_equals',\n    arel_predicate: 'eq',\n    formatter: proc { |v| v.to_date },\n    validator: proc { |v| v.present? },\n    type: :string\nend\n")),(0,l.kt)("h4",{id:"21"},"2.1"),(0,l.kt)("p",null,"It seems to be enough to change the model only, but don't forget to define the type that will returned as well."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},"# in the model:\nransacker :created_at, type: :date do\n  Arel.sql('date(created_at)')\nend\n")),(0,l.kt)("h4",{id:"22-postgresql-with-time-zones"},"2.2. Postgresql with time zones"),(0,l.kt)("p",null,"If you're using different time zones for Rails and Postgresql you should expect to have some problems using the above solution.\nExample:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Rails at GMT -03:00"),(0,l.kt)("li",{parentName:"ul"},"Postgresql at GMT -00:00 (UTC)")),(0,l.kt)("p",null,"A timestamp like ",(0,l.kt)("inlineCode",{parentName:"p"},"2019-07-18 01:21:29.826484")," will be truncated to ",(0,l.kt)("inlineCode",{parentName:"p"},"2019-07-18"),".\nBut for your Rails application ",(0,l.kt)("inlineCode",{parentName:"p"},"2019-07-18 01:21:29.826484")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"2019-07-17 22:21:29.826484")," at your time zone (GMT -03:00). So it should be truncated to ",(0,l.kt)("inlineCode",{parentName:"p"},"2019-07-17")," instead."),(0,l.kt)("p",null,"So, you should convert the timestamp to your current Rails time zone before extracting the date."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},"# in the model:\nransacker :created_at, type: :date do\n  Arel.sql(\"date(created_at at time zone 'UTC' at time zone '#{Time.zone.name}')\")\nend\n")),(0,l.kt)("p",null,"Note that ",(0,l.kt)("inlineCode",{parentName:"p"},"Time.zone.name")," should return a time zone string suitable for Postgresql."),(0,l.kt)("h3",{id:"postgres-columns"},"Postgres columns"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Search on a fixed key in a jsonb / hstore column:")),(0,l.kt)("p",null,"In this example, we are searching a table with a column called ",(0,l.kt)("inlineCode",{parentName:"p"},"properties")," for records containing a key called ",(0,l.kt)("inlineCode",{parentName:"p"},"link_type"),"."),(0,l.kt)("p",null,"For anything up to and including Rails 4.1, add this to your model"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},"ransacker :link_type do |parent|    \n  Arel::Nodes::InfixOperation.new('->>', parent.table[:properties], 'link_type')\nend\n")),(0,l.kt)("p",null,"When using Rails 4.2+ (Arel 6.0+), wrap the value in a ",(0,l.kt)("inlineCode",{parentName:"p"},"build_quoted")," call"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},"ransacker :link_type do |parent|    \n  Arel::Nodes::InfixOperation.new('->>', parent.table[:properties], Arel::Nodes.build_quoted('link_type'))\nend\n")),(0,l.kt)("p",null,"In the view, with a search on ",(0,l.kt)("inlineCode",{parentName:"p"},"link_type_eq")," using a collection select (for example with options like 'twitter', 'facebook', etc.), if the user selects 'twitter', Ransack will run a query like:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'SELECT * FROM "foos" WHERE "foos"."properties" ->> \'link_type\' = \'twitter\';\n')),(0,l.kt)("p",null,"To use the JSONB contains operator @> see here: [","[PostgreSQL JSONB searches]","]."),(0,l.kt)("h3",{id:"type-conversions"},"Type conversions"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Convert an ",(0,l.kt)("inlineCode",{parentName:"em"},"integer")," database field to a ",(0,l.kt)("inlineCode",{parentName:"em"},"string")," in order to be able to use a ",(0,l.kt)("inlineCode",{parentName:"em"},"cont")," predicate (instead of the usual ",(0,l.kt)("inlineCode",{parentName:"em"},"eq")," which works out of the box with integers) to find all records where an integer field (",(0,l.kt)("inlineCode",{parentName:"em"},"id")," in this example) ",(0,l.kt)("strong",{parentName:"em"},"contains")," an input string:")),(0,l.kt)("p",null,"Simple version, using PostgreSQL:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},"# in the model:\nransacker :id do\n  Arel.sql(\"to_char(id, '9999999')\")\nend\n")),(0,l.kt)("p",null,"and the same, using MySQL:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},'ransacker :id do\n  Arel.sql("CONVERT(#{table_name}.id, CHAR(8))")\nend\n')),(0,l.kt)("p",null,"A more complete version (using PostgreSQL) that adds the table name to avoid ambiguity and strips spaces from the input:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},"ransacker :id do\n  Arel.sql(\n    \"regexp_replace(\n      to_char(\\\"#{table_name}\\\".\\\"id\\\", '9999999'), ' ', '', 'g')\"\n  )\nend\n")),(0,l.kt)("p",null,"In the view, for all 3 versions:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erb"},"<%= f.search_field :id_cont, placeholder: 'Id' %>\n...\n<%= sort_link(@search, :id) %>\n")),(0,l.kt)("h3",{id:"concatenated-fields"},"Concatenated fields"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Search on a concatenated full name from ",(0,l.kt)("inlineCode",{parentName:"em"},"first_name")," and ",(0,l.kt)("inlineCode",{parentName:"em"},"last_name")," (several examples):")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},"# in the model:\nransacker :full_name do |parent|\n  Arel::Nodes::InfixOperation.new('||',\n    parent.table[:first_name], parent.table[:last_name])\nend\n\n# or, to insert a space between `first_name` and `last_name`:\nransacker :full_name do |parent|\n  Arel::Nodes::InfixOperation.new('||',\n    Arel::Nodes::InfixOperation.new('||',\n      parent.table[:first_name], ' '\n    ),\n    parent.table[:last_name]\n  )\nend\n# Caveat: with Arel >= 6 the separator ' ' string in the\n# preceding example needs to be quoted as follows:\nransacker :full_name do |parent|\n  Arel::Nodes::InfixOperation.new('||',\n    Arel::Nodes::InfixOperation.new('||',\n      parent.table[:first_name], Arel::Nodes.build_quoted(' ')\n    ),\n    parent.table[:last_name]\n  )\nend\n\n# works also in mariadb\nransacker :full_name do |parent|\n  Arel::Nodes::NamedFunction.new('concat_ws',\n    [Arel::Nodes::SqlLiteral.new(\"' '\"), parent.table[:first_name], parent.table[:last_name]])\nend\n\n# case insensitive lookup\nransacker :full_name, formatter: proc { |v| v.mb_chars.downcase.to_s } do |parent|\n  Arel::Nodes::NamedFunction.new('LOWER',\n    [Arel::Nodes::NamedFunction.new('concat_ws',\n      [Arel::Nodes::SqlLiteral.new(\"' '\"), parent.table[:first_name], parent.table[:last_name]])])\nend\n")),(0,l.kt)("h3",{id:"passing-arguments"},"Passing arguments"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Passing arguments to a ransacker:"),"\nArguments may be passed to a ransacker method via ",(0,l.kt)("inlineCode",{parentName:"p"},"ransacker_args"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},"\nclass Person\n  ransacker :author_max_title_of_article_where_body_length_between,\n  args: [:parent, :ransacker_args] do |parent, args|\n    min, max = args\n    query = <<-SQL\n      (SELECT MAX(articles.title)\n         FROM articles\n        WHERE articles.person_id = people.id\n          AND CHAR_LENGTH(articles.body) BETWEEN #{min.to_i} AND #{max.to_i}\n        GROUP BY articles.person_id\n      )\n    SQL\n    Arel.sql(query)\n  end\nend\n\n# Usage\nPerson.ransack(\n  conditions: [{\n    attributes: {\n      '0' => {\n        name: 'author_max_title_of_article_where_body_length_between',\n        ransacker_args: [10, 100]\n      }\n    },\n    predicate_name: 'cont',\n    values: ['Ransackers can take arguments']\n  }]\n)\n\n=> SELECT \"people\".* FROM \"people\" WHERE (\n     (SELECT MAX(articles.title)\n        FROM articles\n       WHERE articles.person_id = people.id\n         AND CHAR_LENGTH(articles.body) BETWEEN 10 AND 100\n       GROUP BY articles.person_id\n     )\n   LIKE '%Ransackers can take arguments%')\n   ORDER BY \"people\".\"id\" DESC\n")),(0,l.kt)("h3",{id:"dropdowns"},"Dropdowns"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Adding the attribute values associated with a column name to a searchable attribute in a dropdown options (instead of a traditional column name coming from a table). This is useful if using an associated table which is acting as a join table between a parent table and domain table. This will cache the data as the selections:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},"# in the model:\nModel.pluck(:name).each do |ground|\n  ransacker ground.to_sym do |parent|\n    Arel::Nodes::InfixOperation.new('AND',\n      Arel::Nodes::InfixOperation.new('=', parent.table[:gor_name], ground),\n      parent.table[:status]\n    )\n  end\nend\n\n# This will not include the column names in the dropdown\ndef self.ransackable_attributes(auth_object = nil)\n  %w() + _ransackers.keys\nend\n")),(0,l.kt)("h3",{id:"testing-for-existence"},"Testing for existence"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Testing for the existence of a row in another table via a join:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},'# in the model:\nransacker :price_exists do |parent|\n  # SQL syntax for PostgreSQL -- others may differ\n  # This returns boolean true or false\n  Arel.sql("(select exists (select 1 from prices where prices.book_id = books.id))")\nend\n')),(0,l.kt)("p",null,"In the view"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haml"},'  %td= f.select :price_exists_true, [["Any", 2], ["No", 0], ["Yes", 1]]\n')),(0,l.kt)("h3",{id:"associations"},"Associations"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Performing a query on an association with a differing class name:")),(0,l.kt)("p",null,'Say we have a model "SalesAccount", which represents a relationship between two users,\none being designated as a "sales_rep". We want to query SalesAccounts by\nthe name of the sales_rep:'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},'# in the model:\nclass SalesAccount < ActiveRecord::Base\n  belongs_to :user\n  belongs_to :sales_rep, class_name: :User\n\n# in the controller:\n  # The line below would lead to errors thrown later if not for the\n  # "joins(:sales_reps)".\n  @q = SalesAccount.includes(:user).joins(:sales_rep).ransack(params[:q])\n  @sales_accounts = @q.result(distinct: true)\n')),(0,l.kt)("p",null,"In the view:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-erb"},"<%= f.search_field :sales_rep_name_start %>\n")),(0,l.kt)("h3",{id:"search-on-translations"},"Search on translations"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Search for a translated value in a jsonb column:")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Note: There is also a gem, ",(0,l.kt)("a",{parentName:"em",href:"https://github.com/shioyama/mobility-ransack"},"Mobility Ransack"),", which allows you to search on translated attributes independent of their storage backend.")),(0,l.kt)("p",null,"This will work with any ",(0,l.kt)("inlineCode",{parentName:"p"},"jsonb")," data type. In this case I have a column translated with ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/shioyama/mobility"},"Mobility")," called ",(0,l.kt)("inlineCode",{parentName:"p"},"name")," with the value ",(0,l.kt)("inlineCode",{parentName:"p"},"{'en': \"Hello\", 'es': \"Hola\"}"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},"ransacker :name do |parent|    \n  Arel::Nodes::InfixOperation.new('->>', parent.table[:name], Arel::Nodes.build_quoted(Mobility.locale))\nend\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"If using Rails 4.1 or under, remove the ",(0,l.kt)("inlineCode",{parentName:"em"},"build_quoted")," call.")),(0,l.kt)("p",null,"You can then search for ",(0,l.kt)("inlineCode",{parentName:"p"},"name_eq")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"name_cont")," and it will do the proper SQL."),(0,l.kt)("hr",null),(0,l.kt)("p",null,"Please feel free to contribute further code examples!"))}m.isMDXComponent=!0}}]);